ğŸ”‘ The server signs the JWT â€” always.


var jwtKey = []byte("my_secret_key") // Keep this safe in env

This line declares and initializes a variable jwtKey of type 
[]byte (a byte slice) containing the string "my_secret_key".

This key is used to sign and verify JWT tokens securely.

ğŸ“Œ JWT Background
              - JWT (JSON Web Token) is a token format often used for 
                authentication and authorization.
              - JWT tokens are signed so that no one can tamper with their contents.
              - Signing is done using:
                  - HS256 (HMAC + SHA256) â†’ needs a secret key
                  - or RSA â†’ needs private/public keys


ğŸ’¡ Purpose of jwtKey:
    SIGNING the token:
           token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
           tokenString, err := token.SignedString(jwtKey) // uses this key
    VERIFYING the token later:
        token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) {
            return jwtKey, nil
        })
        
The jwtKey must match exactly in both signing and verifying,
or the token will be invalid.




âš ï¸ Why []byte, not just string?
The JWT library expects the signing key to be a byte slice, not a plain string.
Go strings are immutable and not suitable for cryptographic operations directly.





ğŸ”„ FLOW OF JWT AUTHENTICATION + AUTHORIZATION
 Action                         Who Does It          Explanation                                                                            
 ğŸ§‘â€ğŸ’» Login Request        Client â†’ Server  Client (browser, CLI, mobile) sends credentials (username/password) to the server.     
 âœ… Authenticate + Sign JWT  Server           Server checks credentials, creates a JWT token, and signs it with a secret key.    
 ğŸ“© Send JWT to Client      Server â†’ Client  Server sends back the signed JWT. Client stores it (memory/localStorage/cookie).       
 ğŸ” Authorized Request      Client â†’ Server  Client includes JWT in the Authorization header when calling protected routes.     
 âœ… Verify JWT               Server           Server reads the token, verifies the signature using the same secret key.          
 ğŸ”“ Authorize Access        Server           If valid and user has permission (like role = admin), server lets the request through. 




âœ… What is Signing a JWT?
The server creates a token:
                            {
                              "username": "mahindra",
                              "role": "admin"
                            }
        It signs it using a secret key (jwtKey) to create something like:
                                      eyJhbGciOi...<HEADER>.<PAYLOAD>.<SIGNATURE>
        Signature = Cryptographic hash of header + payload using secret key

ğŸ” Purpose of signing:
        Ensures that the token cannot be changed by anyone (client, hacker, etc.)
        If someone changes even one letter in the payload, the signature breaks.





ğŸ” What is Verifying a JWT?
When the client sends back the token in a request:
                Authorization: Bearer eyJhbGciOi...<HEADER>.<PAYLOAD>.<SIGNATURE>
                The server takes the token, extracts the header and payload,

Then recalculates the signature using the same jwtKey secret,

Compares the new signature with the tokenâ€™s signature:

âœ… If match â†’ token is valid, untampered, and trusted
âŒ If mismatch â†’ token is invalid or forged




ğŸ” What does â€œsigningâ€ a JWT mean?
It's like putting a seal on the token to say:
                    "I, the server, confirm this token is valid and untampered."




â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Client   â”‚          â”‚              Server                â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 1. Sends login credentials (username/password)
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
     â”‚                POST /login { "username", "password" }
     â”‚
     â”‚
     â”‚ 2. Validates credentials
     â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚    â”‚ If valid:                                  â”‚
     â”‚    â”‚ - Create JWT token                         â”‚
     â”‚    â”‚ - Sign it using secret key (jwtKey)        â”‚
     â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ 3. Sends signed JWT token
     â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚       { "token": "eyJhbGciOiJIUzI1NiIsInR..." }      â”‚
     â”‚
     â”‚
     â”‚ 4. Client stores the token (in memory, cookie, etc.)
     â”‚
     â”‚
     â”‚ 5. Sends protected request with token in header
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
     â”‚   GET /admin/dashboard                              â”‚
     â”‚   Authorization: Bearer <JWT token>                 â”‚
     â”‚
     â”‚
     â”‚ 6. Server verifies the token:
     â”‚    - Check signature using secret key
     â”‚    - Check expiry time
     â”‚    - Check user role (authorization)
     â”‚
     â”‚ 7. If all valid, responds with protected resource
     â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚     { "message": "Welcome Admin Mahindra" }         â”‚
     â”‚
     â”‚
     â”‚ âœ¨ DONE â€“ Secured authentication + role-based access
